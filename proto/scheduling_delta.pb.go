// Code generated by protoc-gen-gogo.
// source: scheduling_delta.proto
// DO NOT EDIT!

package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type SchedulingDelta_ChangeType int32

const (
	SchedulingDelta_PLACE   SchedulingDelta_ChangeType = 0
	SchedulingDelta_PREEMPT SchedulingDelta_ChangeType = 1
	SchedulingDelta_MIGRATE SchedulingDelta_ChangeType = 2
	SchedulingDelta_NOOP    SchedulingDelta_ChangeType = 3
)

var SchedulingDelta_ChangeType_name = map[int32]string{
	0: "PLACE",
	1: "PREEMPT",
	2: "MIGRATE",
	3: "NOOP",
}
var SchedulingDelta_ChangeType_value = map[string]int32{
	"PLACE":   0,
	"PREEMPT": 1,
	"MIGRATE": 2,
	"NOOP":    3,
}

func (x SchedulingDelta_ChangeType) String() string {
	return proto1.EnumName(SchedulingDelta_ChangeType_name, int32(x))
}
func (SchedulingDelta_ChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorSchedulingDelta, []int{0, 0}
}

type SchedulingDelta struct {
	TaskId     uint64                     `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	ResourceId string                     `protobuf:"bytes,2,opt,name=resource_id,json=resourceId,proto3" json:"resource_id,omitempty"`
	Type       SchedulingDelta_ChangeType `protobuf:"varint,3,opt,name=type,proto3,enum=proto.SchedulingDelta_ChangeType" json:"type,omitempty"`
}

func (m *SchedulingDelta) Reset()                    { *m = SchedulingDelta{} }
func (m *SchedulingDelta) String() string            { return proto1.CompactTextString(m) }
func (*SchedulingDelta) ProtoMessage()               {}
func (*SchedulingDelta) Descriptor() ([]byte, []int) { return fileDescriptorSchedulingDelta, []int{0} }

func init() {
	proto1.RegisterType((*SchedulingDelta)(nil), "proto.SchedulingDelta")
	proto1.RegisterEnum("proto.SchedulingDelta_ChangeType", SchedulingDelta_ChangeType_name, SchedulingDelta_ChangeType_value)
}
func (m *SchedulingDelta) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SchedulingDelta) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintSchedulingDelta(data, i, uint64(m.TaskId))
	}
	if len(m.ResourceId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintSchedulingDelta(data, i, uint64(len(m.ResourceId)))
		i += copy(data[i:], m.ResourceId)
	}
	if m.Type != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintSchedulingDelta(data, i, uint64(m.Type))
	}
	return i, nil
}

func encodeFixed64SchedulingDelta(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32SchedulingDelta(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintSchedulingDelta(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *SchedulingDelta) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovSchedulingDelta(uint64(m.TaskId))
	}
	l = len(m.ResourceId)
	if l > 0 {
		n += 1 + l + sovSchedulingDelta(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovSchedulingDelta(uint64(m.Type))
	}
	return n
}

func sovSchedulingDelta(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozSchedulingDelta(x uint64) (n int) {
	return sovSchedulingDelta(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SchedulingDelta) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchedulingDelta
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulingDelta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulingDelta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulingDelta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulingDelta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchedulingDelta
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchedulingDelta
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (SchedulingDelta_ChangeType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchedulingDelta(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchedulingDelta
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchedulingDelta(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchedulingDelta
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedulingDelta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchedulingDelta
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthSchedulingDelta
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowSchedulingDelta
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipSchedulingDelta(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthSchedulingDelta = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchedulingDelta   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorSchedulingDelta = []byte{
	// 213 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xe2, 0x12, 0x2b, 0x4e, 0xce, 0x48,
	0x4d, 0x29, 0xcd, 0xc9, 0xcc, 0x4b, 0x8f, 0x4f, 0x49, 0xcd, 0x29, 0x49, 0xd4, 0x2b, 0x28, 0xca,
	0x2f, 0xc9, 0x17, 0x62, 0x05, 0x53, 0x4a, 0xfb, 0x19, 0xb9, 0xf8, 0x83, 0xe1, 0x2a, 0x5c, 0x40,
	0x0a, 0x84, 0xc4, 0xb9, 0xd8, 0x4b, 0x12, 0x8b, 0xb3, 0xe3, 0x33, 0x53, 0x24, 0x18, 0x15, 0x18,
	0x35, 0x58, 0x82, 0xd8, 0x40, 0x5c, 0xcf, 0x14, 0x21, 0x79, 0x2e, 0xee, 0xa2, 0xd4, 0xe2, 0xfc,
	0xd2, 0xa2, 0xe4, 0x54, 0x90, 0x24, 0x13, 0x50, 0x92, 0x33, 0x88, 0x0b, 0x26, 0x04, 0x54, 0x60,
	0xca, 0xc5, 0x52, 0x52, 0x59, 0x90, 0x2a, 0xc1, 0x0c, 0x94, 0xe1, 0x33, 0x52, 0x84, 0x58, 0xa5,
	0x87, 0x66, 0xbe, 0x9e, 0x73, 0x46, 0x62, 0x5e, 0x7a, 0x6a, 0x08, 0x50, 0x61, 0x10, 0x58, 0xb9,
	0x92, 0x35, 0x17, 0x17, 0x42, 0x4c, 0x88, 0x93, 0x8b, 0x35, 0xc0, 0xc7, 0xd1, 0xd9, 0x55, 0x80,
	0x41, 0x88, 0x9b, 0x8b, 0x3d, 0x20, 0xc8, 0xd5, 0xd5, 0x37, 0x20, 0x44, 0x80, 0x11, 0xc4, 0xf1,
	0xf5, 0x74, 0x0f, 0x72, 0x0c, 0x71, 0x15, 0x60, 0x12, 0xe2, 0xe0, 0x62, 0xf1, 0xf3, 0xf7, 0x0f,
	0x10, 0x60, 0x76, 0x12, 0x38, 0xf1, 0x48, 0x8e, 0xf1, 0x02, 0x10, 0x3f, 0x00, 0xe2, 0x19, 0x8f,
	0xe5, 0x18, 0x92, 0xd8, 0xc0, 0xd6, 0x1a, 0x03, 0x02, 0x00, 0x00, 0xff, 0xff, 0xd0, 0xad, 0x8c,
	0xa1, 0xfb, 0x00, 0x00, 0x00,
}
